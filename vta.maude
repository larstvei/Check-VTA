set print with parentheses on .

fmod NAME is
    pr QID .

    sort Name .
    subsort Qid < Name .
endfm

view Name from TRIV to NAME is
    sort Elt to Name .
endv

fmod CAPABILITY is
    pr NAME .

    sort Capability .

    ops c : -> Capability .
    ops in out open : Name -> Capability .
endfm

fmod VTA-SORTS is
    pr NAME .

    sorts Scheduler Tick VTA Servable NeServables Servables .
    subsort Tick < VTA .
    subsort VTA Name < Servable < NeServables < Servables .

    vars N A : NeServables .
    vars E E' : Servable .
    vars S S' : Servables .
    var C : Nat .

    op none : -> Servables [ctor] .
    op _:_ : Servables Servables -> Servables [ctor assoc comm id: none prec 121 format (d r os d)] .
    op _:_ : NeServables Servables -> NeServables [ctor ditto] .

    op _element_ : Servable Servables -> Bool .
    eq E element (E : S) = true .
    eq E element S = false [owise] .

    op size : Servables -> Nat .
    op size : NeServables -> NzNat .
    eq size(S) = size1(S, 0) .

    op size1 : Servables Nat -> Nat .
    eq size1(none, C) = C .
    eq size1((E : S), C) = size1(S, C + 1) [owise] .

    op merge : Servables Servables -> Servables .
    op merge : NeServables Servables -> NeServables .
    op merge : Servables NeServables -> NeServables .
    eq merge(S, S') = S : S' .

    op remove : Servables Servable -> Servables  .
    eq remove(none, E) = none .
    eq remove((E : S), E) = S .
    eq remove((E : S), E') = E : remove(S, E') [owise] .

    op removeAll : Servables Servables -> Servables  .
    eq removeAll(none, A) = none .
    eq removeAll((A : S), A) = removeAll(S, A) .
    eq removeAll((N : S), A) = N : removeAll(S, A) [owise] .
endfm

view Servable from TRIV to VTA-SORTS is
    sort Elt to Servable .
endv

fmod VTA-OPS is
    pr RAT .
    pr VTA-SORTS .
    pr CAPABILITY .

    op tick : -> Tick .

    op sdl : -> Scheduler .
    eq sdl = sched 0 {0, 0, 0, none, none} .
    op sdl : Servables -> Scheduler .
    eq sdl(Unserved) = sched 0 {0, 0, 0, none, Unserved} .

    op sched_{_,_,_,_,_} : Rat Nat Nat Nat Servables Servables -> Scheduler .

    op zero : -> VTA [ctor] .
    op _|_ : VTA VTA -> VTA [id: zero assoc comm prec 90 format (d ni d d)] .
    op _._ : Capability VTA -> VTA [prec 80 frozen (2)] .
    op _[_|_] : Name Scheduler VTA -> VTA [prec 70 format (g++ o d ni d d --)] .

    var Unserved, Served : Servables .
    vars P Q : VTA .
    var Ca : Capability .
    var Sc : Scheduler .
    var N : Name .
    var Speed : Rat .
    vars In Out Rest : Nat .

    op names : VTA -> Servables .
    eq names(zero) = none .
    eq names(tick) = none .
    eq names(Ca . P) = none .
    eq names(N[Sc | P]) = N : names(P) .
    ceq names(P | Q) = names(P) : names(Q) if P =/= zero and Q =/= zero .

    op barb : VTA -> Servables .
    eq barb(Ca . P | Q) = barb(Q) .
    eq barb(N[sched Speed {In, Out, Rest, Unserved, Served} | P] | Q) =
        barb(Q) : if Speed > 0 then N else none fi .
    ceq barb(P | Q) = barb(P) : barb(Q) if P =/= zero and Q =/= zero .
    eq barb(P) = none [owise] .

    op getConsume : Servables -> Servable .
    eq getConsume(((c . P) : Unserved)) = c . P .
    eq getConsume(Unserved) = none [owise] .
endfm

fmod EGYPTIAN is
    pr NAT .
    pr RAT .
    pr LIST{Rat} .

    vars X Y Z : Int .
    var L : List{Rat} .
    var R : Rat .

    op _negmod_ : Int Int -> Int .
    eq X negmod Y = Y + X rem Y .

    op egyptian : Rat -> List{Rat} .
    eq egyptian(R) = gather(egyptian'(R), 0) .

    op egyptian' : Rat -> List{Rat} .
    eq egyptian'(X) = X .
    eq egyptian'(1 / X) = 1 / X .
    ceq egyptian'(X / Y) = (1 / Z) egyptian'((- Y negmod X) / (Y * Z))
      if Z := ceiling(Y / X) [owise] .

    op gather : List{Rat} Nat -> List{Rat} .
    eq gather(1 L, X) = gather(L, X + 1) .
    eq gather(L, X) = X L [owise] .

    op speed : Rat -> List{Rat} .
    ceq speed(R) = X size(L)
      if X L := egyptian(R) .

    op get : Nat List{Rat} -> Rat .
    eq get(1, R L) = R .
    eq get(s(s(X)), R L) = get(s(X), L) .

    op getFraction : Nat Rat -> Nat .
    eq getFraction(X, R) = 1 / get(s(X), egyptian(R)) .
endfm

mod VTA-CALCULUS is
    pr INT .
    pr RAT .
    pr BOOL .
    pr EGYPTIAN .
    pr VTA-OPS .

    vars N M K : Name .
    vars InN OutN RestN InM OutM RestM InK OutK RestK : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars Sc Sc1 Sc2 Sc3 : Scheduler .
    var Ca : Capability .
    vars P Q R U : VTA .
    vars Served Unserved NewParent : Servables .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Servables .

    --- In the example we allow non-unique naming, leading to multisets in the
    --- schedulers.

    op makeUnserved : Name Servables Servables -> Servables .
    op makeServed : Name Servables Servables -> Servables .
    op makeParent : Name Servables Servables Servables -> Servables .

    ceq makeUnserved(N, Unserved, Served) = Unserved
      if N element Served or not(N element merge(Unserved, Served)) .
    eq makeUnserved(N, Unserved, Served) = remove(Unserved, N) [owise] .

    ceq makeServed(N, Unserved, Served) = remove(Served, N) if N element Served .
    eq makeServed(N, Unserved, Served) = Served [owise] .

    ceq makeParent(N, Unserved, Served, NewParent) =  N : NewParent
      if N element merge(Unserved, Served) .
    eq makeParent(N, Unserved, Served, NewParent) =  NewParent [owise] .

    crl [open] :
        M[sched Speed {InM, OutM, RestM, Unserved, Served}
          | open(N) . P | N[Sc | R] | Q]
      =>
        M[sched Speed {InM, OutM, RestM, UnSrvM, SrvM} | P | Q | R]
      if  UnSrvM := makeUnserved(N, Unserved, Served) /\
          SrvM := makeServed(N, Unserved, Served) : barb(P) : barb(R) .

    crl [in] :
        K[sched SpdK {InK, OutK, RestK, UnSrvK, SrvK}
          | N[sched SpdN {InN, OutN, RestN, SrvN, UnSrvN} | in(M) . P | Q]
          | M[sched SpdM {InM, OutM, RestM, SrvM, UnSrvM} | R] | U]
      =>
        K[sched SpdK {InK, OutK, RestK, Unserved, Served}
          | M[sched SpdM {InM, OutM, RestM, SrvM, NewParent} | R
            | N[sched SpdN {InN, OutN, RestN, SrvN, merge(UnSrvN, barb(P))}
              | P | Q]] | U]
      if  Unserved  := makeUnserved(N, UnSrvK, SrvK) /\
          Served    := makeServed(N, UnSrvK, SrvK) /\
          NewParent := makeParent(N, UnSrvK, SrvK, UnSrvM) .

    crl [out] :
        K[sched SpdK {InK, OutK, RestK, UnSrvK, SrvK}
          | M[sched SpdM {InM, OutM, RestM, UnSrvM, SrvM} | R
            | N[sched SpdN {InN, OutN, RestN, UnSrvN, SrvN}
              | out(M) . P | Q]] | U]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, NewParent}
          | N[sched SpdN {InN, OutN, RestN, UnSrvN, merge(SrvN, barb(P))} | P | Q]
          | M[sched SpdM {InM, OutM, RestM, Unserved, Served} | R] | U]
      if  Unserved  := makeUnserved(N, UnSrvM, SrvM) /\
          Served    := makeServed(N, UnSrvM, SrvM) /\
          NewParent := makeParent(N, UnSrvM, SrvM, SrvK) .

    crl [consumption] :
        K[sched SpdK {InK, OutK, RestK, UnSrvK, SrvK} | c . P | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, (SrvK : (c . P))} | R]
      if SpdK > 0 .

    crl [tick]:
        K[sched SpdK {InK, 0, 0, UnSrvK, SrvK} | tick | R]
      =>
        K[sched SpdK {s(InK), OutN, RestN, UnSrvK, SrvK} | R]
      if  OutN RestN := speed(SpdK) .

    crl [new-round] :
        K[sched SpdK {InK, OutK, RestK, none, SrvK} | R]
      =>
        K[sched SpdK {InK, OutK, RestK, SrvK, none} | R]
      if size(SrvK) > 0 .

    crl [primary-tock-consume] :
        K[sched SpdK {InK, s(OutK), RestK, UnSrvK, SrvK} | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvN, SrvK} | R | P]
      if  (c . P) := getConsume(UnSrvK) /\
          UnSrvN := merge(barb(P), remove(UnSrvK, (c . P))) .

    rl [primary-tock-ambient] :
        K[sched SpdK {InK, s(OutK), RestK, (UnSrvK : N), SrvK}
          | N[sched SpdN {InN, OutN, RestN, SrvN, UnSrvN} | Q] | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, (SrvK : N)}
          | N[sched SpdN {InN, OutN, RestN, SrvN, UnSrvN} | tick | Q] | R] .

    crl [secondary-tock-consume1] :
        K[sched SpdK {InK, OutK, s(RestK), UnSrvK, SrvK} | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvN, SrvK} | R | P]
      if  InK rem getFraction(s(RestK), SpdK) == 0 /\
          (c . P) := getConsume(UnSrvK) /\
          UnSrvN := merge(barb(P), remove(UnSrvK, (c . P))) .

    crl [secondary-tock-ambient1] :
        K[sched SpdK {InK, OutK, s(RestK), (UnSrvK : N), SrvK}
          | N[sched SpdN {InN, OutN, RestN, SrvN, UnSrvN} | Q] | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, (SrvK : N)}
          | N[sched SpdN {InN, OutN, RestN, SrvN, UnSrvN} | tick | Q] | R]
      if InK rem getFraction(s(RestK), SpdK) == 0 .

    crl [secondary-tock-no-action] :
        K[sched SpdK {InK, OutK, s(RestK), UnSrvK, SrvK} | P]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, SrvK} | P]
      if  InK rem getFraction(s(RestK), SpdK) =/= 0 .
endm

mod VTA-FORMULA is
    pr VTA-CALCULUS .
    pr BOOL .

    sort Formula .
    sort Var .

    ops True False : -> Formula [ctor format (r o)] .
    op ~_ : Formula -> Formula [ctor prec 53 format (r o d)] .
    op Consume : -> Formula [ctor format (r o)] .
    op NotConsume : -> Formula [ctor format (r o)] .
    op _/\_ : Formula Formula -> Formula [comm ctor gather (E e) prec 55 format (r d d o)] .
    op _\/_ : Formula Formula -> Formula [comm ctor gather (E e) prec 59 format (r d d o)] .
    op void : -> Formula [ctor format (r o)] .
    op _[_] : Name Formula -> Formula [prec 10 format (r d d d o)] .
    op _|_ : Formula Formula -> Formula [comm assoc format (r d d o)] .
    op all_._ : Name Formula -> Formula [format (r d d d o)] .
    op exists_._ : Name Formula -> Formula [format (r d d d o)] .
    op (+)_ : Formula -> Formula [format (r d d d o)] .
    op <>_@__ : Nat Name Formula -> Formula [prec 53 format (r d d d d o)] .
    op <>___ : Rat Nat Formula -> Formula [prec 53 format (r d d d o)] .
    op _@_ : Formula Name -> Formula [format (r d d o)] .
    op someone : Formula -> Formula .
    op no-one : Formula -> Formula .
    op #<_ : Nat -> Formula [prec 53 format (r d o)] .
    op #>_ : Nat -> Formula [prec 53 format (r d o)] .

    vars N M X Y : Name .
    vars F G : Formula .
    vars R : Rat .
    vars A : Nat .

    sort Substitution .
    op [_<-_] : Name Name -> Substitution .

    op __ : Formula Substitution -> Formula [prec 20] .
    eq (~ F)[X <- N] = ~ (F[X <- N]) .
    eq M[F][X <- N] = (if (M == X) then N else M fi)[F[X <- N]] .
    eq (<> A @ M F)[X <- N] = <> A @ (if (M == X) then N else M fi) F[X <- N] .
    eq (F @ M)[X <- N] = F[X <- N] @ (if (M == X) then N else M fi) .
    eq (F \/ G)[X <- N] = F[X <- N] \/ G[X <- N] .
    eq (F | G)[X <- N] = F[X <- N] | G[X <- N] .
    eq (all Y . F)[X <- N] = all Y . F[X <- N] .
    eq (exists Y . F)[X <- N] = exists Y . F[X <- N] .
    eq (<> R A F)[X <- N] = <> R A F[X <- N] .
    eq (someone(F))[X <- N] = someone(F[X <- N]) .
    eq (no-one(F))[X <- N] = no-one(F[X <- N]) .
    eq F[N <- X] = F [owise] .

    var Sc : Scheduler .
    var Ca : Capability .
    vars P Q : VTA .
    vars NS MS : Servables .
    var Ser : Servable .

    op allsubs : Name VTA Formula -> Formula .
    eq allsubs(X, P, F) = allsubs'(X, names(P), F) .

    op allsubs' : Name Servables Formula -> Formula .
    eq allsubs'(X, none, F) = True .
    eq allsubs'(X, (N : NS), F) =  F[X <- N] /\ allsubs'(X, NS, F) .

    op allsubsExist : Name VTA Formula -> Formula .
    eq allsubsExist(X, P, F) = allsubsExist'(X, names(P), F) .

    op allsubsExist' : Name Servables Formula -> Formula .
    eq allsubsExist'(X, none, F) = False .
    eq allsubsExist'(X, (N : NS), F) =  F[X <- N] \/ allsubsExist'(X, NS, F) .

    vars InN OutN RestN InM OutM RestM InK OutK RestK : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Servables .

    op consumptions : VTA -> Bool .
    eq consumptions(c . P) = true .
    eq consumptions(in(N) . P) = consumptions(P) .
    eq consumptions(out(N) . P) = consumptions(P) .
    eq consumptions(open(N) . P) = consumptions(P) .
    ceq consumptions(P | Q) = consumptions(P) or consumptions(Q)
      if P =/= zero and Q =/= zero .
    eq consumptions(N[Sc | P]) = consumptions(P) or consumptions(Sc) .
    eq consumptions(P) = false [owise] .

    op consumptions : Name -> Bool .
    eq consumptions(N) = false .

    op consumptions : Scheduler -> Bool .
    eq consumptions(sched Speed {InN, OutN, RestN, UnSrvN, SrvN}) =
        consumptions1(merge(UnSrvN, SrvN)) .

    op consumptions1 : Servables -> Bool .
    eq consumptions1(none) = false .
    eq consumptions1((Ser : NS)) = consumptions(Ser) or consumptions1(NS) .

    op accumulatespeed : Scheduler VTA -> VTA .
    eq accumulatespeed(sched SpdK{InK, OutK, RestK, UnSrvK, SrvK},
          (N[sched SpdN {InN, OutN, RestN, SrvN, UnSrvN} | P] | Q))
      =
        N[sched ((SpdK * SpdN) / size(merge(UnSrvK, SrvK)))
          {InN, OutN, RestN, SrvN, UnSrvN} | P] |
        accumulatespeed(sched SpdK{InK, OutK, RestK, UnSrvK, SrvK}, Q) .
    ceq accumulatespeed(Sc, P | Q) = accumulatespeed(Sc, P) | accumulatespeed(Sc, Q)
      if P =/= zero and Q =/= zero .
    eq accumulatespeed(Sc, P) = zero [owise] .

    op sublocations : VTA -> Servables .
    ceq sublocations(P | Q) = sublocations(P) : sublocations(Q)
      if P =/= zero and Q =/= zero .
    ceq sublocations(N[Sc | P]) = N[Sc | P] : Q : sublocations(Q)
      if Q := accumulatespeed(Sc, P) .
    eq sublocations(P) = P [owise] .

    op siblings : VTA -> Servables .
    ceq siblings(P | Q) = siblings(P) : siblings(Q)
      if P =/= zero and Q =/= zero .
    eq siblings(N[Sc | P]) = N[Sc | P] .
    eq siblings(P) = none [owise] .

    op contains : VTA Name -> Bool .
    ceq contains(P | Q, X) = contains(P, X) or contains(Q, X)
      if P =/= zero and Q =/= zero .
    eq contains(N[Sc | P], X) = if N == X then true else contains(P, X) fi .
    eq contains(P, X) = false [owise] .

    op time : VTA Name -> Nat .
    ceq time(P | Q, X) = max(time(P, X), time(Q, X))
      if P =/= zero and Q =/= zero .
    eq time(N[sched Speed {InN, OutN, RestN, SrvN, UnSrvN} | P], X) =
        if N == X then InN else time(P, X) fi .
    eq time(P, X) = 0 [owise] .

    op distance : VTA VTA Name -> Nat .
    eq distance(P, Q, X) = sd(time(Q, X), time(P, X)) .
endm

mod VTA-SATISFACTION is
    pr VTA-CALCULUS .
    pr VTA-FORMULA .

    vars F G : Formula .
    vars P Q : VTA .
    vars N X Y : Name .
    var Sc : Scheduler .
    var S : Nat .

    op _|=_ : VTA Formula -> Bool [frozen prec 100] .

    eq [True] : P |= True = true .
    eq [False] : P |= False = false .
    eq [Negation] : P |= ~ F = not (P |= F) .
    eq [Conjunction] : P |= F /\ G = (P |= F) and (P |= G) .
    eq [Disjunction] : P |= F \/ G = (P |= F) or (P |= G) .
    eq [Void] : zero |= void = true .
    eq [Ambient] : N[Sc | P] |= X[F] = if N == X then P |= F else false fi .
    eq [Forall] : P |= all X . F = P |= allsubs(X, P, F) .
    eq [Exists] : P |= exists X . F = P |= allsubsExist(X, P, F) .
    eq [Consumption] : P |= Consume = consumptions(P) .
    eq [NotConsumption] : P |= NotConsume = not(consumptions(P)) .
    ceq [SpatialNext] : P |= (+) F = spatialnext(Ps, F)
      if  Ps := siblings(P) .
    ceq [Somewhere] : P |= <> Speed S F = somewhere(Ps, Speed, S, F)
      if  Ps := sublocations(P) .
    eq [LocalAdjunct] : P |= F @ N = N[sdl | P] |= F .

    crl [Parallel] : P | Q |= F | G => true
      if P |= F => true /\ Q |= G => true .

    crl [Sometime] : P |= <> A @ X F => true
      if  contains(P, X) /\
          P => Q /\
          distance(P, Q, X) <= A /\
          contains(Q, X) /\
          Q |= F => true .

    --- We define additional formulas as equational short-cuts for the modality
    --- formulas which use backtracking and slow down the computation.

    --- LessSubs and MoreSubs are short for Q |= <> 0 S N[True] and its negation.
    eq [LessSubs] : N[sched Speed {InN, OutN, RestN, SrvN, UnSrvN} | P]
        |= #< S  = size(merge(SrvN, UnSrvN)) <= S .
    eq [MoreSubs] : N[sched Speed {InN, OutN, RestN, SrvN, UnSrvN} | P]
        |= #> S  = size(merge(SrvN, UnSrvN)) > S .

    --- SomeOne and NoOne are short for P |= F | True and its negation.
    ceq [SomeOne] : P |= someone(F) = anysat(Ps, F)
      if  Ps := siblings(P) .
    ceq [NoOne] : P |= no-one(F) = not(anysat(Ps, F))
      if  Ps := siblings(P) .

    rl [Sometime-else] : P |= F => false .

    var Ps : Servables .
    vars R : Rat .
    vars A : Nat .
    vars InN OutN RestN InM OutM RestM InK OutK RestK : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Servables .

    op somewhere : Servables Rat Nat Formula -> Bool .
    eq somewhere((N[sched Speed {InN, OutN, RestN, SrvN, UnSrvN} | P] : Ps), R, A, F) =
        ((P |= F)
          and (Speed >= R)
          and (size(merge(SrvN, UnSrvN)) <= A))
        or somewhere(Ps, R, A, F) .
    eq somewhere(Ps, R, A, F) = false [owise] .

    op spatialnext : Servables Formula -> Bool .
    eq spatialnext((N[Sc | P] : Ps), F) = (P |= F) or spatialnext(Ps, F) .
    eq spatialnext(Ps, F) = false [owise] .

    op anysat : Servables Formula -> Bool .
    eq anysat((P : Ps), F) = (P |= F) or anysat(Ps, F) .
    eq anysat(none, F) = false [owise] .


endm

view Formula from TRIV to VTA-FORMULA is
    sort Elt to Formula .
endv

mod REPLICATION is
    pr VTA-SATISFACTION .
    pr SET{Formula} .
    pr CONVERSION .
    pr COUNTER .

    vars P Q R : VTA .
    vars N M Y X : Name .
    vars G F : Formula .
    var Gs : Set{Formula} .
    var Ca : Capability .
    var O : Rat .
    var I : Nat .
    var S : String .
    var C : Char .
    var Sdl : Scheduler .
    vars In Out Rest : Nat .
    vars Speed : Rat .
    vars Served Unserved : Servables .

   op {_} : VTA -> VTA .

    op removeNumber : String -> String .
    eq removeNumber(S) = removeNumber1(0, S) .

    op removeNumber1 : Nat String -> String .
    ceq removeNumber1(I, S) = S if s length(S) == I .
    ceq removeNumber1(I, S) = removeNumber1(I, substr(S, 0, I) + substr(S, s I, length(S)))
        if 48 <= ascii(substr(S, I, 1)) /\ ascii(substr(S, I, 1)) <= 57 .
    eq removeNumber1(I, S) = removeNumber1(s I, S) [owise] .

    op removeNumber : Name -> Name .
    eq removeNumber(N) = qid(removeNumber(string(N))) .

    op removeNumbers : Capability -> Capability .
    eq removeNumbers(c) = c .
    eq removeNumbers(in(N)) = in(removeNumber(N)) .
    eq removeNumbers(out(N)) = out(removeNumber(N)) .
    eq removeNumbers(open(N)) = open(removeNumber(N)) .

    op removeNumbers : VTA -> VTA .
    eq removeNumbers(zero) = zero .
    eq removeNumbers(tick) = tick .
    eq removeNumbers(Ca . P) = removeNumbers(Ca) . removeNumbers(P) .
    eq removeNumbers(N[Sdl | P]) = removeNumber(N)[Sdl | removeNumbers(P)] .
    ceq removeNumbers(P | Q) = removeNumbers(P) | removeNumbers(Q) if P =/= zero and Q =/= zero .
    eq removeNumbers(! P) = ! removeNumbers(P) .
    eq removeNumbers(!< Names, I > P) = !< Names, I > removeNumbers(P) .

    op removeNumbers : Formula -> Formula .
    eq removeNumbers(True) = True .
    eq removeNumbers(False) = False .
    eq removeNumbers(~ F) = ~ removeNumbers(F) .
    eq removeNumbers(Consume) = Consume .
    eq removeNumbers(NotConsume) = NotConsume .
    eq removeNumbers(M[F]) = removeNumber(M)[removeNumbers(F)] .
    eq removeNumbers(<> I @ M F) = <> I @ removeNumber(M) removeNumbers(F) .
    eq removeNumbers(F @ M) = removeNumbers(F) @ removeNumber(M) .
    eq removeNumbers(F \/ G) = removeNumbers(F) \/ removeNumbers(G) .
    eq removeNumbers(F /\ G) = removeNumbers(F) /\  removeNumbers(G) .
    eq removeNumbers(F | G) = removeNumbers(F) | removeNumbers(G) .
    eq removeNumbers(all Y . F) = all Y . removeNumbers(F) .
    eq removeNumbers(exists Y . F) = exists Y . removeNumbers(F) .
    eq removeNumbers(<> O I F) = <> O I removeNumbers(F) .
    eq removeNumbers((+) F) = (+) removeNumbers(F) .
    eq removeNumbers(someone(F)) = someone(removeNumbers(F)) .
    eq removeNumbers(no-one(F)) = no-one(removeNumbers(F)) .
    eq removeNumbers(#< I) = #< I .
    eq removeNumbers(#> I) = #> I .

    op _privatecontains_ : VTA VTA -> Bool .
    eq P privatecontains Q = removeNumbers(P) contains1 removeNumbers(Q) .

    op _contains_ : VTA VTA -> Bool .
    eq P contains Q = P contains1 Q .

    op _contains1_ : VTA VTA -> Bool .
    ceq (Q | R) contains1 P = Q contains1 P or R contains1 P if Q =/= zero and R =/= zero .
    eq P contains1 P = true .
    eq Q contains1 P = false [owise] .

    op substitute : Servables VTA -> VTA .
    eq substitute(none, P) = P .
    eq substitute((N : Names), P) = substitute(Names, substitute1(N, P)) .

    op substitute1 : Name Capability -> Capability .
    ceq substitute1(N, in(M)) = in(N) if removeNumber(N) == M .
    ceq substitute1(N, out(M)) = out(N) if removeNumber(N) == M .
    ceq substitute1(N, open(M)) = open(N) if removeNumber(N) == M .
    eq substitute1(N, Ca) = Ca [owise] .

    op substitute1 : Name Formula -> Formula .
    eq substitute1(N, True) = True .
    eq substitute1(N, False) = False .
    eq substitute1(N, ~ F) = ~ substitute1(N, F) .
    eq substitute1(N, Consume) = Consume .
    eq substitute1(N, NotConsume) = NotConsume .
    eq substitute1(N, M[F]) = (if (removeNumber(N) == M) then N else M fi)[substitute1(N, F)] .
    eq substitute1(N, <> I @ M F) = <> I @ (if (removeNumber(N) == M) then N else M fi) substitute1(N, F) .
    eq substitute1(N, F @ M) = substitute1(N, F) @ (if (removeNumber(N) == M) then N else M fi) .
    eq substitute1(N, F /\ G) = substitute1(N, F) /\ substitute1(N, G) .
    eq substitute1(N, F \/ G) = substitute1(N, F) \/ substitute1(N, G) .
    eq substitute1(N, F | G) = substitute1(N, F) | substitute1(N, G) .
    eq substitute1(N, all Y . F) = all Y . substitute1(N, F) .
    eq substitute1(N, exists Y . F) = exists Y . substitute1(N, F) .
    eq substitute1(N, <> O I F) = <> O I substitute1(N, F) .
    eq substitute1(N, (+) F) = (+) substitute1(N, F) .
    eq substitute1(N, someone(F)) = someone(substitute1(N, F)) .
    eq substitute1(N, no-one(F)) = no-one(substitute1(N, F)) .
    eq substitute1(N, #< I) = #< I .
    eq substitute1(N, #> I) = #> I .


    op substitute1 : Name VTA -> VTA .
    eq substitute1(N, zero) = zero .
    eq substitute1(N, tick) = tick .
    eq substitute1(N, Ca . P) = substitute1(N, Ca) . substitute1(N, P) .
    eq substitute1(N, M[Sdl | P]) = if removeNumber(N) == M then N[Sdl | substitute1(N, P)] else M[Sdl | substitute1(N, P)] fi .
    eq substitute1(N, ! P) = ! substitute1(N, P) .
    eq substitute1(N, !< Names, I > P) = !< Names, I > substitute1(N, P) .
    ceq substitute1(N, P | Q) = substitute1(N, P) | substitute1(N, Q) if P =/= zero and Q =/= zero .

    --- Additional cases for consumptions
    eq consumptions(! P) = consumptions(P) .
    eq consumptions(!< Names, I > P) = consumptions(P) .

    --- Additional cases for names
    eq names(! P) =  names(P) .
    eq names(!< Names, I > P) =  removeAll(names(P), Names) .

    var Names : Servables .
    var PrivateNames : [Servables] .

    op makePrivateName : Name Nat -> Name .
    eq makePrivateName(N, I) = qid(string(N) + string(I, 10)) .

    op makePrivateNames : Servables Nat -> Servables .
    eq makePrivateNames(none, I) = none .
    eq makePrivateNames((N : Names), I) =
        makePrivateName(N, I) : makePrivateNames(Names, I) .

    op !_ : VTA -> VTA .
    op !<_,_>_ : Servables Nat VTA -> VTA .

    crl [Replication] : { ! P | Q } => { ! P | P | Q } if not(Q contains P) .

    crl [AmbientReplication] :
        N[sched Speed {In, Out, Rest, Served, Unserved} | ! P | Q]
      =>
        N[sched Speed {In, Out, Rest, Served, merge(Unserved, barb(P))} | ! P | P | Q]
      if not(Q contains P) .

    crl [PrivateReplication] :
        { !< Names, I > P | Q }
      =>
        { !< Names, s(I) > P | substitute(PrivateNames, P) | Q }
      if not(Q privatecontains P) /\ PrivateNames := makePrivateNames(Names, I) .

    crl [PrivateAmbientReplication] :
        N[sched Speed {In, Out, Rest, Served, Unserved}| !< Names, I > P | Q]
      =>
        N[sched Speed {In, Out, Rest, Served, merge(Unserved, barb(P))}
          | !< Names, s(I) > P | substitute(PrivateNames, P) | Q]
      if not(Q privatecontains P) /\ PrivateNames := makePrivateNames(Names, I) .

endm

mod CLOUD-LIBRARY is
    pr REPLICATION .
    pr RAT .
    pr NAT .
    pr LIST{Rat} .

    vars P : VTA .
    vars I K L : Nat .
    vars Speed : Rat .
    vars N X Y : Name .
    vars Ns : Servables .
    vars Rs : List{Rat} .

    --- system
    --- cloud

    op time-slices : Nat -> VTA .
    eq time-slices(0) = zero .
    eq time-slices(s K) = tick | time-slices(K) .

    op consumes : Nat -> VTA .
    eq consumes(0) = 'done[sdl | zero] .
    eq consumes(s K) = c . consumes(K) .

    --- applications need to be executed, need computation
    --- data needs to be stored, needs memory

    --- to speed up the model-checking
    --- we omit the movement of the applications and data packages into the cloud
    --- and start with a configuration where they are already inside.

    op application : Nat -> VTA .
    eq application(K) =
        'app[sdl |  open('move) . zero | consumes(K)] .

    op data : Nat -> VTA .
    eq data(K) =
        'app[sdl |  open('move) . zero
          | 'data[sched 1 {0, 0, 0, none, none} |  consumes(K) | open('done) .  zero ] ] .


    --- create K apps each requesting L resources, or K data sets

    op createApps : Nat Nat -> VTA .
    eq createApps(s K , L ) = application(L) | createApps(K , L) .
    eq createApps(0 , L) = zero .

    op createDatas : Nat Nat  -> VTA .
    eq createDatas(s K , L ) = data(L ) | createDatas(K, L) .
    eq createDatas(0 , L ) = zero .

    --- ROUND-ROBIN Load Balancing
    --- VMs are predefined and get applications in a round-robin way

    op round-robin-lb : Servables -> VTA .
    eq round-robin-lb(Ns) = ! (open('round_lock) . balance(Ns)) .

    op balance : Servables -> VTA .
    eq balance((N : Ns)) = open('load_balancer_lock) . (moveTo(N) | balance(Ns)) .
    eq balance(none) = 'round_lock[sdl | zero] .

    op moveTo : Name -> VTA .
    eq moveTo(X) = 'move[sdl |  in('app) . in(X) . 'load_balancer_lock[sdl | out(X) . zero]] .

    op createRRVMs : Servables List{Rat} -> VTA .
    eq createRRVMs((N : Ns) , (Speed Rs) ) = virtualMachineRR(N , Speed) | createRRVMs(Ns , Rs) .
    eq createRRVMs(none , nil) = zero .

    op virtualMachineRR :  Name Rat -> VTA .
    eq virtualMachineRR(X , Speed) =
        X[sched Speed {0 , 0 , 0 , none, none}
          | ! (open('app) .  open('done) . zero) ] .

    op round-robin : Servables List{Rat} -> VTA .
    eq round-robin(Ns, Rs)=
        round-robin-lb(Ns)
        | 'round_lock[sdl | zero]
        | createRRVMs(Ns, Rs)
        | 'load_balancer_lock[sdl | zero] .

    --- VOLUNTEERING Virtual Machines
    --- VMs are predefined and report to LB that they are free

    op volunteer : Name -> VTA .
    eq volunteer(X) =
        'volunteer[sdl | out (X) . in('lb) . 'move[sdl
            | out('lb) . in('app) . in(X) . 'load_balancer_lock[sdl
              | out(X) .  in('lb) . open('volunteer) . open('load_balancer_lock) . zero]]] .

    op load-balancer : -> VTA .
    eq load-balancer = 'lb[ sdl | open('volunteer) . open('load_balancer_lock) . zero ] .

    op virtualMachineV :  Name Rat -> VTA .
    eq virtualMachineV(X, Speed) =
        X[sched Speed {0, 0, 0, none, none}
          | volunteer(X)
          | ! (open('app) . open('done) . volunteer(X)) ] .

    op createVVMs : Servables List{Rat} -> VTA .
    eq createVVMs((N : Ns), (Speed Rs) ) = virtualMachineV(N, Speed) | createVVMs(Ns, Rs) .
    eq createVVMs(none , nil) = zero .

    op volunteering : Servables List{Rat}  -> VTA .
    eq volunteering(Ns, Rs) =  createVVMs(Ns, Rs)  | load-balancer .

    --- AUTO-SCALING
    --- for each application a new VM is created
    --- the VM deletes itself after the application is done

    op scaling : Rat -> VTA .
    eq scaling(Speed) =
        !< 'vm, 0 >  (open('scaling_lock) . ('move[sdl
              | in('app) . (open('move) . zero | 'detected[sdl | out('app) . zero])]
            | open('detected) . virtualMachineAS('vm, Speed))) .

    op virtualMachineAS :  Name Rat -> VTA .
    eq virtualMachineAS(X, Speed) =
        X[sched Speed {0, 0, 0, none, none}
          | 'move[sdl |  out(X) . in('app) . in(X) . 'scaling_lock[sdl | out(X) . zero]]
          | open('app) . zero
          | open('done) . in('garbage) . zero] .

    op garbage : -> VTA .
    eq garbage = 'garbage[sdl | zero ] .

    op auto-scaling : Rat -> VTA .
    eq auto-scaling(Speed) = garbage | scaling(Speed) | 'scaling_lock[sdl | zero] .

    --- SPECIAL DATA

    op observable : Nat -> VTA .
    eq observable(K) =
        'app[sdl | open('move) . zero
          | 'special_data[sched 1 {0, 0, 0, none, none} |  consumes(K)
            | open('done) .  zero ]] .

    --- FORMULAS

    --- Are there less or equal to K subambients in the cloud the end?
    op F1-orig : Nat -> Formula .
    eq F1-orig(K) =
        <> 0 @ 'system 'system[~ Consume /\ (<> 0 K ('isCloud[True] | True))] .

    --- F1 with "cheat-formulas" for faster computation:
    op F1 : Nat -> Formula .
    eq F1(K) = <> 0 @ 'system 'system[~ Consume /\ someone('cloud[True] /\ #< K)] .

    --- Are less than K resources needed?
    op F2 : Nat -> Formula .
    eq F2(K) = <> K @ 'cloud 'system[~ Consume] .

    ---How many resources until special one is done?
    op F3-orig : Nat -> Formula .
    eq F3-orig(K) = <> K @ 'cloud 'system['cloud[(+) ('special_data[~ Consume] | True)]] .

    ---F3 with cheat-formulas for faster computation:
    op F3 : Nat -> Formula .
    eq F3(K) = <> K @ 'cloud 'system['cloud[ (+) someone('special_data[~ Consume])]] .

    --- EXAMPLES
    op example : VTA Servables -> VTA .
    eq example(P, Ns) =
        'system[sdl | 'cloud[sched 1 {0, 0, 0, none, Ns}
            | P
            | time-slices(5)
            | createApps(1 , 1)
            | observable(1)]] .

    op exampleRR : -> VTA .
    eq exampleRR = example(round-robin(('vm0 : 'vm1), (1 1)), ('vm0 : 'vm1)) .

    op exampleV : -> VTA .
    eq exampleV  = example(volunteering(('vm0 : 'vm1), (1 1)), ('vm0 : 'vm1)) .

    op exampleAS : -> VTA .
    eq exampleAS = example(auto-scaling(1), none) .
endm

