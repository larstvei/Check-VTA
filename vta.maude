fmod NAME is
    pr QID .

    sort Name .
    subsort Qid < Name .
endfm

view Name from TRIV to NAME is
    sort Elt to Name .
endv

fmod CAPABILITY is
    pr NAME .

    sort Capability .

    ops c : -> Capability .
    ops in out open : Name -> Capability .
endfm

fmod VTA-SORTS is
    pr NAME .

    sorts Clock Tick Servable TimedProcess .
    subsort Tick < TimedProcess .
    subsort TimedProcess Name < Servable .
endfm

view Servable from TRIV to VTA-SORTS is
    sort Elt to Servable .
endv

fmod VTA-OPS is
    pr RAT .
    pr VTA-SORTS .
    pr CAPABILITY .
    pr SET{Servable} .

    op tick : -> Tick .

    op dummyclock : -> Clock .
    op clock : Nat Nat Nat Rat Set{Servable} Set{Servable} -> Clock .

    op dead : -> TimedProcess [ctor] .
    op _|_ : TimedProcess TimedProcess -> TimedProcess [id: dead assoc comm prec 90] .
    op _._ : Capability TimedProcess -> TimedProcess [prec 80] .
    op _[_|_] : Name Clock TimedProcess -> TimedProcess [prec 70 format (ni+ d d d d d -)] .

    var Unserved : Set{Servable} .
    vars P Q : TimedProcess .
    var Ca : Capability .
    var Cl : Clock .
    var N : Name .

    op names : Capability -> Set{Servable} .
    eq names(c) = empty .
    eq names(in(N)) = N .
    eq names(out(N)) = N .
    eq names(open(N)) = N .

    op names : TimedProcess -> Set{Servable} .
    eq names(dead) = empty .
    eq names(tick) = empty .
    eq names(Ca . P) = names(Ca), names(P) .
    eq names(N[Cl | P]) = N, names(P) .
    ceq names(P | Q) = names(P), names(Q) if P =/= dead and Q =/= dead .

    op barb : TimedProcess -> Set{Servable} .
    eq barb(Ca . P | Q) = barb(Q) .
    eq barb(N[Cl | P] | Q) = N, barb(Q) .
    eq barb(P) = empty [owise] .

    op getConsume : Set{Servable} -> Servable .
    eq getConsume(((c . P), Unserved)) = c . P .
    eq getConsume(Unserved) = empty [owise] .
endfm

fmod EGYPTIAN is
    pr NAT .
    pr RAT .
    pr LIST{Rat} .

    vars X Y Z : Int .
    var L : List{Rat} .
    var R : Rat .

    op _negmod_ : Int Int -> Int .
    eq X negmod Y = Y + X rem Y .

    op egyptian : Rat -> List{Rat} .
    eq egyptian(R) = gather(egyptian'(R), 0) .

    op egyptian' : Rat -> List{Rat} .
    eq egyptian'(X) = X .
    eq egyptian'(1 / X) = 1 / X .
    ceq egyptian'(X / Y) = (1 / Z) egyptian'((- Y negmod X) / (Y * Z))
      if Z := ceiling(Y / X) [owise] .

    op gather : List{Rat} Nat -> List{Rat} .
    eq gather(1 L, X) = gather(L, X + 1) .
    eq gather(L, X) = X L [owise] .

    op speed : Rat -> List{Rat} .
    ceq speed(R) = X size(L)
      if X L := egyptian(R) .

    op get : Nat List{Rat} -> Rat .
    eq get(1, R L) = R .
    eq get(s(s(X)), R L) = get(s(X), L) .

    op getFraction : Nat Rat -> Nat .
    eq getFraction(X, R) = 1 / get(s(X), egyptian(R)) .
endfm

mod TIMED-PROCESS is
    pr INT .
    pr RAT .
    pr BOOL .
    pr SET{Servable} .
    pr EGYPTIAN .
    pr VTA-OPS .

    vars N M K : Name .
    vars CN1 CN2 CN3 CM1 CM2 CM3 CK1 CK2 CK3 : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars Cl Cl1 Cl2 Cl3 : Clock .
    var Ca : Capability .
    vars P Q R U : TimedProcess .
    vars Served Unserved : Set{Servable} .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Set{Servable} .

    crl [open] :
        M[clock(CM1, CM2, CM3, Speed, Unserved, Served)
          | open(N) . P | N[Cl | R] | Q]
      =>
        M[clock(CM1, CM2, CM3, Speed, UnSrvM, SrvM) | P | Q | R]
      if  UnSrvM := (Unserved \ N) /\
          SrvM := (Served \ N), barb(P), barb(R) /\
          N in (Served, Unserved) .

    crl [in] :
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK)
          | N[clock(CN1, CN2, CN3, SpdN, SrvN, UnSrvN) | in(M) . P | Q]
          | M[clock(CM1, CM2, CM3, SpdM, SrvM, UnSrvM) | R] | U]
      =>
        K[clock(CK1, CK2, CK3, SpdK, (UnSrvK \ N), (SrvK \ N))
          | M[clock(CM1, CM2, CM3, SpdM, SrvM, (UnSrvM, N)) | R |
            N[clock(CN1, CN2, CN3, SpdN, SrvN, (UnSrvN, barb(P))) | P | Q]] | U]
      if  N in (UnSrvK, SrvK) .

    crl [out] :
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK)
          | M[clock(CM1, CM2, CM3, SpdM, SrvM, UnSrvM) | R |
            N[clock(CN1, CN2, CN3, SpdN, SrvN, UnSrvN) | out(M) . P | Q]] | U]
      =>
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, (SrvK, N))
          | N[clock(CN1, CN2, CN3, SpdN, SrvN, (UnSrvN, barb(P))) | P | Q]
          | M[clock(CM1, CM2, CM3, SpdM, (SrvM \ N), (UnSrvM \ N)) | R] | U]
      if  N in (SrvM, UnSrvM) .

    crl [consumption] :
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK) | c . P | R]
      =>
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, (SrvK, (c . P))) | R]
      if SpdK > 0 .

    rl [empty]:
        K[clock(CK1, 0, 0, SpdK, empty, empty) | tick | R]
      =>
        K[clock(s(CK1), 0, 0, SpdK, empty, empty) | R] .

    crl [tick]:
        K[clock(CK1, 0, 0, SpdK, UnSrvK, SrvK) | tick | R]
      =>
        K[clock(s(CK1), CN2, CN3, SpdK, UnSrvK, SrvK) | R]
      if  CN2 CN3 := speed(SpdK) /\ | UnSrvK, SrvK | > 0 .

    crl [new-round] :
        K[clock(CK1, CK2, CK3, SpdK, empty, SrvK) | R]
      =>
        K[clock(CK1, CK2, CK3, SpdK, SrvK, empty) | R]
      if | SrvK | > 0 .

    crl [primary-tock-consume] :
        K[clock(CK1, s(CK2), CK3, SpdK, UnSrvK, SrvK) | R]
      =>
        K[clock(CK1, CK2, CK3, SpdK, UnSrvN, SrvK) | R | P]
      if  (c . P) := getConsume(UnSrvK) /\
          UnSrvN := (barb(P), UnSrvK \ (c . P)) .

    rl [primary-tock-ambient] :
        K[clock(CK1, s(CK2), CK3, SpdK, (UnSrvK, N), SrvK) | N[Cl | Q] | R]
      =>
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, (SrvK, N)) | N[Cl | tick | Q] | R] .

    crl [secondary-tock-consume1] :
        K[clock(CK1, CK2, s(CK3), SpdK, UnSrvK, SrvK) | R]
      =>
        K[clock(CK1, CK2, CK3, SpdK, UnSrvN, SrvK) | R | P]
      if  CK1 rem getFraction(s(CK3), SpdK) == 0 /\
          (c . P) := getConsume(UnSrvK) /\
          UnSrvN := (barb(P), UnSrvK \ (c . P)) .

    crl [secondary-tock-ambient1] :
        K[clock(CK1, CK2, s(CK3), SpdK, (UnSrvK, N), SrvK) | N[Cl | Q] | R]
      =>
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, (SrvK, N)) | N[Cl | tick | Q] | R]
      if CK1 rem getFraction(s(CK3), SpdK) == 0 .

    crl [secondary-tock-no-action] :
        K[clock(CK1, CK2, s(CK3), SpdK, UnSrvK, SrvK) | P]
      =>
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK) | P]
      if  CK1 rem getFraction(s(CK3), SpdK) =/= 0 .
endm

mod VTA-FORMULA is
    pr TIMED-PROCESS .
    pr BOOL .

    sort Formula .
    sort Var .

    ops True False : -> Formula [ctor format (g o)] .
    op Consume : -> Formula [ctor] .
    op ~_ : Formula -> Formula [ctor prec 53 format (r o d)] .
    op _/\_ : Formula Formula -> Formula [comm ctor gather (E e) prec 55 format (d r o d)] .
    op _\/_ : Formula Formula -> Formula [comm ctor gather (E e) prec 59 format (d r o d)] .
    op void : -> Formula [ctor format (r o)] .
    op _[_] : Name Formula -> Formula [prec 10] .
    op _|_ : Formula Formula -> Formula [comm assoc] .
    op all_._ : Name Formula -> Formula .
    op <>_@__ : Nat Name Formula -> Formula [prec 53] .
    op <>___ : Rat Nat Formula -> Formula [prec 53] .
    op _@_ : Formula Name -> Formula .

    vars N M X Y : Name .
    vars F G : Formula .
    vars R : Rat .
    vars A : Nat .

    sort Substitution .
    op [_<-_] : Name Name -> Substitution .

    op __ : Formula Substitution -> Formula [prec 20] .
    eq (~ F)[X <- N] = ~ (F[X <- N]) .
    eq M[F][X <- N] = (if (M == X) then N else M fi)[F[X <- N]] .
    eq (<> A @ M F)[X <- N] = <> A @ (if (M == X) then N else M fi) F[X <- N] .
    eq (F @ M)[X <- N] = F[X <- N] @ (if (M == X) then N else M fi) .
    eq (F \/ G)[X <- N] = F[X <- N] \/ G[X <- N] .
    eq (F | G)[X <- N] = F[X <- N] | G[X <- N] .
    eq (all Y . F)[X <- N] = all Y . F[X <- N] .
    eq (<> R A F)[X <- N] = <> R A F[X <- N] .
    eq F[N <- X] = F [owise] .

    var Cl : Clock .
    var Ca : Capability .
    vars P Q : TimedProcess .
    vars NS MS : Set{Servable} .

    op allsubs : Name TimedProcess Formula -> Formula .
    eq allsubs(X, P, F) = allsubs'(X, names(P), F) .

    op allsubs' : Name Set{Servable} Formula -> Formula .
    eq allsubs'(X, empty, F) = True .
    eq allsubs'(X, (N, NS), F) =  F[X <- N] /\ allsubs'(X, NS, F) .

    vars CN1 CN2 CN3 CM1 CM2 CM3 CK1 CK2 CK3 : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Set{Servable} .

    op consumptions : TimedProcess -> Bool .
    eq consumptions(c . P) = true .
    eq consumptions(in(N) . P) = consumptions(P) .
    eq consumptions(out(N) . P) = consumptions(P) .
    eq consumptions(open(N) . P) = consumptions(P) .
    ceq consumptions(P | Q) = consumptions(P) or consumptions(Q)
      if P =/= dead and Q =/= dead .
    eq consumptions(N[Cl | P]) = consumptions(P) .
    eq consumptions(P) = false [owise] .

    op accumulatespeed : Clock TimedProcess -> TimedProcess .
    eq accumulatespeed(clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK),
          (N[clock(CN1, CN2, CN3, SpdN, SrvN, UnSrvN) | P] | Q))
      =
        N[clock(CN1, CN2, CN3, SpdN * SpdK, SrvN, UnSrvN) | P] |
        accumulatespeed(clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK), Q) .
    ceq accumulatespeed(Cl, P | Q) = accumulatespeed(Cl, P) | accumulatespeed(Cl, Q)
      if P =/= dead and Q =/= dead .
    eq accumulatespeed(Cl, P) = dead [owise] .

    op sublocations : TimedProcess -> Set{Servable} .
    ceq sublocations(P | Q) = sublocations(P), sublocations(Q)
      if P =/= dead and Q =/= dead .
    ceq sublocations(N[Cl | P]) = N[Cl | P], Q, sublocations(Q)
      if Q := accumulatespeed(Cl, P) .
    eq sublocations(P) = P [owise] .

    op contains : TimedProcess Name -> Bool .
    ceq contains(P | Q, X) = contains(P, X) or contains(Q, X)
      if P =/= dead and Q =/= dead .
    eq contains(N[Cl | P], X) = if N == X then true else contains(P, X) fi .
    eq contains(P, X) = false [owise] .

    op time : TimedProcess Name -> Nat .
    ceq time(P | Q, X) = max(time(P, X), time(Q, X))
      if P =/= dead and Q =/= dead .
    eq time(N[clock(CN1, CN2, CN3, Speed, SrvN, UnSrvN) | P], X) =
        if N == X then CN1 else time(P, X) fi .
    eq time(P, X) = 0 [owise] .

    op distance : TimedProcess TimedProcess Name -> Nat .
    eq distance(P, Q, X) = sd(time(Q, X), time(P, X)) .
endm

mod VTA-SATISFACTION is
    pr TIMED-PROCESS .
    pr VTA-FORMULA .

    vars F G : Formula .
    vars P Q : TimedProcess .
    vars N X : Name .
    var Cl : Clock .
    var S : Nat .

    op _|=_ : TimedProcess Formula -> Bool [frozen prec 100] .

    eq [True] : P |= True = true .
    eq [False] : P |= False = false .
    eq [Negation] : P |= ~ F = not (P |= F) .
    eq [Conjunction] : P |= F /\ G = (P |= F) and (P |= G) .
    eq [Disjunction] : P |= F \/ G = (P |= F) or (P |= G) .
    eq [Void] : dead |= void = true .
    eq [Ambient] : N[Cl | P] |= X[F] = if N == X then P |= F else false fi .
    eq [Parallel] : P | Q |= F | G = (P |= F) and (Q |= G) or (P |= G) and (Q |= F) .
    eq [Forall] : P |= all X . F = P |= allsubs(X, P, F) .
    eq [Consumption] : P |= Consume = consumptions(P) .
    ceq [Somewhere] : P |= <> Speed S F = somewhere(Ps, Speed, S, F)
      if  Ps := sublocations(P) .
    eq [LocalAdjunct] : P |= F @ N = N[dummyclock | P] |= F .

    crl [Sometime] : P |= <> A @ X F => true
      if  contains(P, X) /\
          P => Q /\
          contains(Q, X) /\
          Q |= F /\
          distance(P, Q, X) <= A .

    rl [Sometime-else] : P |= F => false .

    var Ps : Set{Servable} .
    vars R : Rat .
    vars A : Nat .
    vars CN1 CN2 CN3 CM1 CM2 CM3 CK1 CK2 CK3 : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Set{Servable} .

    op somewhere : Set{Servable} Rat Nat Formula -> Bool .
    eq somewhere((N[clock(CN1, CN2, CN3, Speed, SrvN, UnSrvN) | P], Ps), R, A, F) =
        ((N[clock(CN1, CN2, CN3, Speed, SrvN, UnSrvN) | P] |= F)
          and (Speed >= R)
          and (| SrvN, UnSrvN | <= A))
        or somewhere(Ps, R, A, F) .
    eq somewhere(Ps, R, A, F) = false [owise] .
endm

--- Examples
rew 'm[clock(0,0,0,0,'n,empty) | 'n[C1:Clock | 'p[C2:Clock | dead]]
      | open('n) . 'q[C3:Clock | dead]] .

rew 'k[clock(0,0,0,0,('n,'m),empty)
      | 'n[clock(0,0,0,0,empty,empty) | in('m) . dead]
      | 'm[clock(0,0,0,0,empty,empty) | dead]] .


rew 'k[clock(0,0,0,0,('m),empty)
     | 'm[clock(0,0,0,0,('n),empty) | dead
     | 'n[clock(0,0,0,0,empty,empty) | out('m) . dead]]] .

rew 'k[clock(0,0,0,1, empty, empty) | c . dead] .

rew 'k[clock(0,0,0,1, empty, empty) | tick] .

rew 'k[clock(0,0,0,1, 'n, empty) | tick] .

rew 'k[clock(0,0,0,1, empty, 'n) | tick] .

rew 'k[clock(0,1,0,1, (c . P:TimedProcess), 'n) | dead] .

rew 'k[clock(0,1,0,1, 'n, empty) | 'n[Cl:Clock | P:TimedProcess]] .

rew 'k[clock(3,0,1,1/3, (c . P:TimedProcess), 'n) | dead] .

rew 'k[clock(0,0,0,4/3,'n,empty) | c . c . dead
      | 'n[clock(0,0,0,1/2,empty,empty) | c . dead]
      | tick | tick | tick] .

--- should be false:
rew
'k[clock(0,0,0,1,('vm,'r),empty) |
'vm[clock(0,0,0,1/2,empty,empty) | tick | tick | open('r) . dead]
| 'r[clock(0,0,0,0,empty,empty) | in('vm) . c . 'done[clock(0,0,0,0,empty,empty) | out('vm) . dead]]]

|

'n[clock(0,0,0,1,('vm,'r),empty) |
'vm[clock(0,0,0,1/2,empty,empty) | tick | tick | open('r) . dead]
| 'r[clock(0,0,0,0,empty,empty) | in('vm) . c . 'done[clock(0,0,0,0,empty,empty) | out('vm) . dead]]]


|= 'n[True] | (<> 1 @ 'vm 'k[True | 'done[True]]) .

--- should be true:
rew

'k[clock(0,0,0,1,('vm,'r),empty) |
'vm[clock(0,0,0,1/2,empty,empty) | tick | tick | open('r) . dead]
| 'r[clock(0,0,0,0,empty,empty) | in('vm) . c . 'done[clock(0,0,0,0,empty,empty) | out('vm) . dead]]]

|

'n[clock(0,0,0,1,('vm,'r),empty) |
'vm[clock(0,0,0,1/2,empty,empty) | tick | tick | open('r) . dead]
| 'r[clock(0,0,0,0,empty,empty) | in('vm) . c . 'done[clock(0,0,0,0,empty,empty) | out('vm) . dead]]]


|= 'n[True] | (<> 2 @ 'vm 'k[True | 'done[True]]) .

rew

 'root[clock(0, 0, 0, 1, 'request, 'vm) | tick | tick |
  'request[clock(0, 0, 0, 0, empty, empty) | in('vm) . c . dead] |
  'vm[clock(0, 0, 0, 3/4, empty, empty) | open('request) . dead]]

   |= <> 2 @ 'vm ~ Consume .

rew

 'root[clock(0, 0, 0, 1, 'request, 'vm) | tick | tick |
  'request[clock(0, 0, 0, 0, empty, empty) | in('vm) . c . dead] |
  'vm[clock(0, 0, 0, 3/4, empty, empty) | open('request) . dead]]

   |= ~ (all X . (~ (<> 2 @ X ~ Consume))) .

rew
'root[clock(0, 0, 0, 1, 'request, 'vm) | tick | tick |
 'request[clock(0, 0, 0, 0, empty, empty) | in('vm) . c . dead] |
  'vm[clock(0, 0, 0, 3/4, empty, empty) | open('request) . dead]]

  |= ~ <> 2 @ 'request ~ Consume .

rew

 'root[clock(0, 0, 0, 1, 'request, 'vm) | tick | tick |
  'request[clock(0, 0, 0, 0, empty, empty) | in('vm) . c . dead] |
  'vm[clock(0, 0, 0, 3/4, empty, empty) | open('request) . dead]]

   |= (<> 2 @ 'vm (<> 2 @ 'vm True)) .