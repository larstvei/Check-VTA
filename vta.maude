fmod NAME is
    pr QID .

    sort Name .
    subsort Qid < Name .
endfm

view Name from TRIV to NAME is
    sort Elt to Name .
endv

fmod CAPABILITY is
    pr NAME .

    sort Capability .

    ops c : -> Capability .
    ops in out open : Name -> Capability .
endfm

fmod VTA-SORTS is
    pr NAME .

    sorts Scheduler Tick Servable VTA .
    subsort Tick < VTA .
    subsort VTA Name < Servable .
endfm

view Servable from TRIV to VTA-SORTS is
    sort Elt to Servable .
endv

fmod VTA-OPS is
    pr RAT .
    pr VTA-SORTS .
    pr CAPABILITY .
    pr SET{Servable} .

    op tick : -> Tick .

    op sdl : -> Scheduler .
    eq sdl = sched 0 {0, 0, 0, empty, empty} .
    op sdl : Set{Servable} -> Scheduler .
    eq sdl(Unserved) = sched 0 {0, 0, 0, empty, Unserved} .

    op sched_{_,_,_,_,_} : Rat Nat Nat Nat Set{Servable} Set{Servable} -> Scheduler .

    op zero : -> VTA [ctor] .
    op _|_ : VTA VTA -> VTA [id: zero assoc comm prec 90] .
    op _._ : Capability VTA -> VTA [prec 80] .
    op _[_|_] : Name Scheduler VTA -> VTA [prec 70 format (ni+ d d d d d -)] .

    var Unserved : Set{Servable} .
    vars P Q : VTA .
    var Ca : Capability .
    var Sc : Scheduler .
    var N : Name .

    op names : Capability -> Set{Servable} .
    eq names(c) = empty .
    eq names(in(N)) = N .
    eq names(out(N)) = N .
    eq names(open(N)) = N .

    op names : VTA -> Set{Servable} .
    eq names(zero) = empty .
    eq names(tick) = empty .
    eq names(Ca . P) = names(Ca), names(P) .
    eq names(N[Sc | P]) = N, names(P) .
    ceq names(P | Q) = names(P), names(Q) if P =/= zero and Q =/= zero .

    op barb : VTA -> Set{Servable} .
    eq barb(Ca . P | Q) = barb(Q) .
    eq barb(N[Sc | P] | Q) = N, barb(Q) .
    eq barb(P) = empty [owise] .

    op getConsume : Set{Servable} -> Servable .
    eq getConsume(((c . P), Unserved)) = c . P .
    eq getConsume(Unserved) = empty [owise] .
endfm

fmod EGYPTIAN is
    pr NAT .
    pr RAT .
    pr LIST{Rat} .

    vars X Y Z : Int .
    var L : List{Rat} .
    var R : Rat .

    op _negmod_ : Int Int -> Int .
    eq X negmod Y = Y + X rem Y .

    op egyptian : Rat -> List{Rat} .
    eq egyptian(R) = gather(egyptian'(R), 0) .

    op egyptian' : Rat -> List{Rat} .
    eq egyptian'(X) = X .
    eq egyptian'(1 / X) = 1 / X .
    ceq egyptian'(X / Y) = (1 / Z) egyptian'((- Y negmod X) / (Y * Z))
      if Z := ceiling(Y / X) [owise] .

    op gather : List{Rat} Nat -> List{Rat} .
    eq gather(1 L, X) = gather(L, X + 1) .
    eq gather(L, X) = X L [owise] .

    op speed : Rat -> List{Rat} .
    ceq speed(R) = X size(L)
      if X L := egyptian(R) .

    op get : Nat List{Rat} -> Rat .
    eq get(1, R L) = R .
    eq get(s(s(X)), R L) = get(s(X), L) .

    op getFraction : Nat Rat -> Nat .
    eq getFraction(X, R) = 1 / get(s(X), egyptian(R)) .
endfm

mod VTA-CALCULUS is
    pr INT .
    pr RAT .
    pr BOOL .
    pr SET{Servable} .
    pr EGYPTIAN .
    pr VTA-OPS .

    vars N M K : Name .
    vars InN OutN RestN InM OutM RestM InK OutK RestK : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars Sc Sc1 Sc2 Sc3 : Scheduler .
    var Ca : Capability .
    vars P Q R U : VTA .
    vars Served Unserved : Set{Servable} .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Set{Servable} .

    crl [open] :
        M[sched Speed {InM, OutM, RestM, Unserved, Served}
          | open(N) . P | N[Sc | R] | Q]
      =>
        M[sched Speed {InM, OutM, RestM, UnSrvM, SrvM} | P | Q | R]
      if  UnSrvM := (Unserved \ N) /\
          SrvM := (Served \ N), barb(P), barb(R) /\
          N in (Served, Unserved) .

    crl [in] :
        K[sched SpdK {InK, OutK, RestK, UnSrvK, SrvK}
          | N[sched SpdN {InN, OutN, RestN, SrvN, UnSrvN} | in(M) . P | Q]
          | M[sched SpdM {InM, OutM, RestM, SrvM, UnSrvM} | R] | U]
      =>
        K[sched SpdK {InK, OutK, RestK, (UnSrvK \ N), (SrvK \ N)}
          | M[sched SpdM {InM, OutM, RestM, SrvM, union(UnSrvM, N)} | R
            | N[sched SpdN {InN, OutN, RestN, SrvN, union(UnSrvN, barb(P))}
              | P | Q]] | U]
      if  N in union(UnSrvK, SrvK) .

    crl [out] :
        K[sched SpdK {InK, OutK, RestK, UnSrvK, SrvK}
          | M[sched SpdM {InM, OutM, RestM, SrvM, UnSrvM} | R
            | N[sched SpdN {InN, OutN, RestN, SrvN, UnSrvN}
              | out(M) . P | Q]] | U]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, (SrvK, N)}
          | N[sched SpdN {InN, OutN, RestN, SrvN, (UnSrvN, barb(P))} | P | Q]
          | M[sched SpdM {InM, OutM, RestM, (SrvM \ N), (UnSrvM \ N)} | R] | U]
      if  N in (SrvM, UnSrvM) .

    crl [consumption] :
        K[sched SpdK {InK, OutK, RestK, UnSrvK, SrvK} | c . P | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, (SrvK, (c . P))} | R]
      if SpdK > 0 .

    rl [empty]:
        K[sched SpdK {InK, 0, 0, empty, empty} | tick | R]
      =>
        K[sched SpdK {s(InK), 0, 0, empty, empty} | R] .

    crl [tick]:
        K[sched SpdK {InK, 0, 0, UnSrvK, SrvK} | tick | R]
      =>
        K[sched SpdK {s(InK), OutN, RestN, UnSrvK, SrvK} | R]
      if  OutN RestN := speed(SpdK) /\ | UnSrvK, SrvK | > 0 .

    crl [new-round] :
        K[sched SpdK {InK, OutK, RestK, empty, SrvK} | R]
      =>
        K[sched SpdK {InK, OutK, RestK, SrvK, empty} | R]
      if | SrvK | > 0 .

    crl [primary-tock-consume] :
        K[sched SpdK {InK, s(OutK), RestK, UnSrvK, SrvK} | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvN, SrvK} | R | P]
      if  (c . P) := getConsume(UnSrvK) /\
          UnSrvN := (barb(P), UnSrvK \ (c . P)) .

    rl [primary-tock-ambient] :
        K[sched SpdK {InK, s(OutK), RestK, (UnSrvK, N), SrvK} | N[Sc | Q] | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, (SrvK, N)} | N[Sc | tick | Q] | R] .

    crl [secondary-tock-consume1] :
        K[sched SpdK {InK, OutK, s(RestK), UnSrvK, SrvK} | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvN, SrvK} | R | P]
      if  InK rem getFraction(s(RestK), SpdK) == 0 /\
          (c . P) := getConsume(UnSrvK) /\
          UnSrvN := (barb(P), UnSrvK \ (c . P)) .

    crl [secondary-tock-ambient1] :
        K[sched SpdK {InK, OutK, s(RestK), (UnSrvK, N), SrvK} | N[Sc | Q] | R]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, (SrvK, N)} | N[Sc | tick | Q] | R]
      if InK rem getFraction(s(RestK), SpdK) == 0 .

    crl [secondary-tock-no-action] :
        K[sched SpdK {InK, OutK, s(RestK), UnSrvK, SrvK} | P]
      =>
        K[sched SpdK {InK, OutK, RestK, UnSrvK, SrvK} | P]
      if  InK rem getFraction(s(RestK), SpdK) =/= 0 .
endm

mod VTA-FORMULA is
    pr VTA-CALCULUS .
    pr BOOL .

    sort Formula .
    sort Var .

    ops True False : -> Formula [ctor format (g o)] .
    op Consume : -> Formula [ctor] .
    op ~_ : Formula -> Formula [ctor prec 53 format (r o d)] .
    op _/\_ : Formula Formula -> Formula [comm ctor gather (E e) prec 55 format (d r o d)] .
    op _\/_ : Formula Formula -> Formula [comm ctor gather (E e) prec 59 format (d r o d)] .
    op void : -> Formula [ctor format (r o)] .
    op _[_] : Name Formula -> Formula [prec 10] .
    op _|_ : Formula Formula -> Formula [comm assoc] .
    op all_._ : Name Formula -> Formula .
    op exists_._ : Name Formula -> Formula .
    op (+)_ : Formula -> Formula .
    op <>_@__ : Nat Name Formula -> Formula [prec 53] .
    op <>___ : Rat Nat Formula -> Formula [prec 53] .
    op _@_ : Formula Name -> Formula .

    vars N M X Y : Name .
    vars F G : Formula .
    vars R : Rat .
    vars A : Nat .

    sort Substitution .
    op [_<-_] : Name Name -> Substitution .

    op __ : Formula Substitution -> Formula [prec 20] .
    eq (~ F)[X <- N] = ~ (F[X <- N]) .
    eq M[F][X <- N] = (if (M == X) then N else M fi)[F[X <- N]] .
    eq (<> A @ M F)[X <- N] = <> A @ (if (M == X) then N else M fi) F[X <- N] .
    eq (F @ M)[X <- N] = F[X <- N] @ (if (M == X) then N else M fi) .
    eq (F \/ G)[X <- N] = F[X <- N] \/ G[X <- N] .
    eq (F | G)[X <- N] = F[X <- N] | G[X <- N] .
    eq (all Y . F)[X <- N] = all Y . F[X <- N] .
    eq (exists Y . F)[X <- N] = exists Y . F[X <- N] .
    eq (<> R A F)[X <- N] = <> R A F[X <- N] .
    eq F[N <- X] = F [owise] .

    var Sc : Scheduler .
    var Ca : Capability .
    vars P Q : VTA .
    vars NS MS : Set{Servable} .

    op allsubs : Name VTA Formula -> Formula .
    eq allsubs(X, P, F) = allsubs'(X, names(P), F) .

    op allsubs' : Name Set{Servable} Formula -> Formula .
    eq allsubs'(X, empty, F) = True .
    eq allsubs'(X, (N, NS), F) =  F[X <- N] /\ allsubs'(X, NS, F) .

    vars InN OutN RestN InM OutM RestM InK OutK RestK : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Set{Servable} .

    op consumptions : VTA -> Bool .
    eq consumptions(c . P) = true .
    eq consumptions(in(N) . P) = consumptions(P) .
    eq consumptions(out(N) . P) = consumptions(P) .
    eq consumptions(open(N) . P) = consumptions(P) .
    ceq consumptions(P | Q) = consumptions(P) or consumptions(Q)
      if P =/= zero and Q =/= zero .
    eq consumptions(N[Sc | P]) = consumptions(P) .
    eq consumptions(P) = false [owise] .

    op accumulatespeed : Scheduler VTA -> VTA .
    eq accumulatespeed(sched SpdK{InK, OutK, RestK, UnSrvK, SrvK},
          (N[sched SpdN {InN, OutN, RestN, SrvN, UnSrvN} | P] | Q))
      =
        N[sched ((SpdK * SpdN) / | union(UnSrvK, SrvK) |)
          {InN, OutN, RestN, SrvN, UnSrvN} | P] |
        accumulatespeed(sched SpdK{InK, OutK, RestK, UnSrvK, SrvK}, Q) .
    ceq accumulatespeed(Sc, P | Q) = accumulatespeed(Sc, P) | accumulatespeed(Sc, Q)
      if P =/= zero and Q =/= zero .
    eq accumulatespeed(Sc, P) = zero [owise] .

    op sublocations : VTA -> Set{Servable} .
    ceq sublocations(P | Q) = sublocations(P), sublocations(Q)
      if P =/= zero and Q =/= zero .
    ceq sublocations(N[Sc | P]) = N[Sc | P], Q, sublocations(Q)
      if Q := accumulatespeed(Sc, P) .
    eq sublocations(P) = P [owise] .

    op siblings : VTA -> Set{Servable} .
    ceq siblings(P | Q) = siblings(P), siblings(Q)
      if P =/= zero and Q =/= zero .
    eq siblings(N[Sc | P]) = N[Sc | P] .
    eq siblings(P) = empty [owise] .

    op contains : VTA Name -> Bool .
    ceq contains(P | Q, X) = contains(P, X) or contains(Q, X)
      if P =/= zero and Q =/= zero .
    eq contains(N[Sc | P], X) = if N == X then true else contains(P, X) fi .
    eq contains(P, X) = false [owise] .

    op time : VTA Name -> Nat .
    ceq time(P | Q, X) = max(time(P, X), time(Q, X))
      if P =/= zero and Q =/= zero .
    eq time(N[sched Speed {InN, OutN, RestN, SrvN, UnSrvN} | P], X) =
        if N == X then InN else time(P, X) fi .
    eq time(P, X) = 0 [owise] .

    op distance : VTA VTA Name -> Nat .
    eq distance(P, Q, X) = sd(time(Q, X), time(P, X)) .
endm

mod VTA-SATISFACTION is
    pr VTA-CALCULUS .
    pr VTA-FORMULA .

    vars F G : Formula .
    vars P Q : VTA .
    vars N X : Name .
    var Sc : Scheduler .
    var S : Nat .

    op _|=_ : VTA Formula -> Bool [frozen prec 100] .

    eq [True] : P |= True = true .
    eq [False] : P |= False = false .
    eq [Negation] : P |= ~ F = not (P |= F) .
    eq [Conjunction] : P |= F /\ G = (P |= F) and (P |= G) .
    eq [Disjunction] : P |= F \/ G = (P |= F) or (P |= G) .
    eq [Void] : zero |= void = true .
    eq [Ambient] : N[Sc | P] |= X[F] = if N == X then P |= F else false fi .
    eq [Forall] : P |= all X . F = P |= allsubs(X, P, F) .
    eq [Exists] : P |= exists X . F = P |= ~ (all X . (~ F)) .
    eq [Consumption] : P |= Consume = consumptions(P) .
    ceq [SpatialNext] : P |= (+) F = spatialnext(Ps, F)
      if  Ps := siblings(P) .
    ceq [Somewhere] : P |= <> Speed S F = somewhere(Ps, Speed, S, F)
      if  Ps := sublocations(P) .
    eq [LocalAdjunct] : P |= F @ N = N[sdl | P] |= F .

    crl [Parallel] : P | Q |= F | G => true
      if P |= F => true /\ Q |= G => true .

    crl [Sometime] : P |= <> A @ X F => true
      if  contains(P, X) /\
          P => Q /\
          distance(P, Q, X) <= A /\
          contains(Q, X) /\
          Q |= F => true .

    rl [Sometime-else] : P |= F => false .

    var Ps : Set{Servable} .
    vars R : Rat .
    vars A : Nat .
    vars InN OutN RestN InM OutM RestM InK OutK RestK : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Set{Servable} .

    op somewhere : Set{Servable} Rat Nat Formula -> Bool .
    eq somewhere((N[sched Speed {InN, OutN, RestN, SrvN, UnSrvN} | P], Ps), R, A, F) =
        ((P |= F)
          and (Speed >= R)
          and (| SrvN, UnSrvN | <= A))
        or somewhere(Ps, R, A, F) .
    eq somewhere(Ps, R, A, F) = false [owise] .

    op spatialnext : Set{Servable} Formula -> Bool .
    eq spatialnext((N[Sc | P], Ps), F) =
        (P |= F) or spatialnext(Ps, F) .
    eq spatialnext(Ps, F) = false [owise] .
endm

view Formula from TRIV to VTA-FORMULA is
    sort Elt to Formula .
endv

mod RESOURCE-AWARE is
    pr VTA-SATISFACTION .
    pr SET{Formula} .
    pr CONVERSION .
    pr COUNTER .

    op {_} : VTA -> VTA .
    op {_,_} : VTA Formula -> VTA [frozen] .
    op _?_ : Formula VTA -> VTA .

    vars P Q R : VTA .
    vars G F : Formula .
    vars N M : Name .
    var Gs : Set{Formula} .
    var Ca : Capability .
    var I : Nat .
    var S : String .
    var C : Char .
    var Sdl : Scheduler .
    vars In Out Rest : Nat .
    vars Speed : Rat .
    vars Served Unserved : Set{Servable} .


    op findGuards : VTA -> Set{Formula} .
    eq findGuards(zero) = empty .
    eq findGuards(G ? P) = G .
    ceq findGuards(P | Q) = union(findGuards(P), findGuards(Q)) if P =/= zero /\ Q =/= zero .
    eq findGuards(N[Sdl | P]) = findGuards(P) .

    op removeGuard : VTA Formula -> VTA .
    eq removeGuard(zero, G) = zero .
    eq removeGuard(N[sched Speed {In, Out, Rest, Served, Unserved} | G ? P | Q], G) =
        N[sched Speed {In, Out, Rest, Served, (Unserved, barb(P))} | P | Q] .
    ceq removeGuard(F ? P, G) = F ? P if F =/= G .
    ceq removeGuard(P | Q, G) = removeGuard(P, G) | removeGuard(Q, G) if P =/= zero /\ Q =/= zero .
    eq removeGuard(N[Sdl | P], G) = N[Sdl | removeGuard(P, G)] .

    op removeGuardedProcess : VTA Formula -> VTA .
    eq removeGuardedProcess(zero, G) = zero .
    eq removeGuardedProcess(G ? P, G) = zero .
    ceq removeGuardedProcess(F ? P, G) = F ? P if F =/= G .
    ceq removeGuardedProcess(P | Q, G) = removeGuardedProcess(P, G) | removeGuardedProcess(Q, G) if P =/= zero /\ Q =/= zero .
    eq removeGuardedProcess(N[Sdl | P], G) = N[Sdl | removeGuardedProcess(P, G)] .

    op removeNumber : String -> String .
    eq removeNumber(S) = removeNumber1(0, S) .

    op removeNumber1 : Nat String -> String .
    ceq removeNumber1(I, S) = S if s length(S) == I .
    ceq removeNumber1(I, S) = removeNumber1(I, substr(S, 0, I) + substr(S, s I, length(S)))
        if 48 <= ascii(substr(S, I, 1)) /\ ascii(substr(S, I, 1)) <= 57 .
    eq removeNumber1(I, S) = removeNumber1(s I, S) [owise] .

    op removeNumber : Name -> Name .
    eq removeNumber(N) = qid(removeNumber(string(N))) .

    op removeNumbers : Capability -> Capability .
    eq removeNumbers(c) = c .
    eq removeNumbers(in(N)) = in(removeNumber(N)) .
    eq removeNumbers(out(N)) = out(removeNumber(N)) .
    eq removeNumbers(open(N)) = open(removeNumber(N)) .

    op removeNumbers : VTA -> VTA .
    eq removeNumbers(zero) = zero .
    eq removeNumbers(tick) = tick .
    eq removeNumbers(Ca . P) = removeNumbers(Ca) . removeNumbers(P) .
    eq removeNumbers(N[Sdl | P]) = removeNumber(N)[Sdl | removeNumbers(P)] .
    ceq removeNumbers(P | Q) = removeNumbers(P) | removeNumbers(Q) if P =/= zero and Q =/= zero .

    op _contains_ : VTA VTA -> Bool .
    eq P contains Q = removeNumbers(P) contains1 removeNumbers(Q) .

    op _contains1_ : VTA VTA -> Bool .
    ceq (Q | R) contains1 P = Q contains1 P or R contains1 P if Q =/= zero and R =/= zero .
    eq P contains1 P = true .
    eq Q contains1 P = false [owise] .

    --- op substitute : Map{Name, Name} Set{Servable} VTA -> VTA .
    op substitute : Set{Servable} VTA -> VTA .
    eq substitute(empty, P) = P .
    eq substitute((N, Names), P) = substitute(Names, substitute1(N, P)) .

    op substitute1 : Name Capability -> Capability .
    ceq substitute1(N, in(M)) = in(N) if removeNumber(N) == M .
    ceq substitute1(N, out(M)) = out(N) if removeNumber(N) == M .
    ceq substitute1(N, open(M)) = open(N) if removeNumber(N) == M .
    eq substitute1(N, Ca) = Ca [owise] .

    op substitute1 : Name VTA -> VTA .
    eq substitute1(N, zero) = zero .
    eq substitute1(N, tick) = tick .
    eq substitute1(N, Ca . P) = substitute1(N, Ca) . substitute1(N, P) .
    eq substitute1(N, M[Sdl | P]) = if removeNumber(N) == M then N[Sdl | substitute1(N, P)] else M[Sdl | substitute1(N, P)] fi .
    ceq substitute1(N, P | Q) = substitute1(N, P) | substitute1(N, Q) if P =/= zero and Q =/= zero .

    var Names : Set{Servable} .
    var PrivateNames : [Set{Servable}] .

    op makePrivateName : Name -> Name .
    eq makePrivateName(N) = qid(string(N) + string(counter, 10)) .

    op makePrivateNames : Set{Servable} -> Set{Servable} .
    eq makePrivateNames(empty) = empty .
    eq makePrivateNames((N, Names)) = makePrivateName(N), makePrivateNames(Names) .

    op !_ : VTA -> VTA .
    op !<_>_ : Set{Servable} VTA -> VTA .
    crl { ! P | Q } => { ! P | P | Q } if not(Q contains P) .
    crl N[sched Speed {In, Out, Rest, Served, Unserved} | ! P | Q]
      =>
        N[sched Speed {In, Out, Rest, Served, (Unserved, barb(P))} | ! P | P | Q]
      if not(Q contains P) .

    crl { !< Names > P | Q } => { !< Names > P | substitute(PrivateNames, P) | Q }
      if not(Q contains P) /\ PrivateNames := makePrivateNames(Names) .
    crl N[sched Speed {In, Out, Rest, Served, Unserved}| !< Names > P | Q]
      =>
        N[sched Speed {In, Out, Rest, Served, (Unserved, barb(P))}
          | !< Names > P | substitute(PrivateNames, P) | Q]
      if not(Q contains P) /\ PrivateNames := makePrivateNames(Names) .

    crl { P } => { P, G } if G, Gs := findGuards(P) .
    crl { P, G } => { removeGuard(P, G) }
      if removeGuardedProcess(P, G) |= G => true .
    crl { P, G } => { P } if removeGuardedProcess(P, G) |= G => false .
endm

mod AUTO-SCALING-EXAMPLE is
    pr RESOURCE-AWARE .

    vars K : Nat .
    vars X Y : Name .

    ops MIN MAX : -> Nat .
    eq MIN = 2 .
    eq MAX = 4 .

    op full : Name -> Formula .
    eq full(X) = (+)(+)(~(<> 1 @ X (X[~ Consume] | True))) .

    op empty : Name -> Formula .
    eq empty(X) = (+)(+)(X[~ Consume] | True) .

    op exists : Name -> Formula .
    eq exists(X) = (+)(+)(X[True] | True) .

    op parallel : Name Name -> Formula .
    eq parallel(X, Y) = (+)(+)(X[True] | Y[True] | True) .

    op _has_ : Name Name -> Formula .
    eq X has Y = (+)(+)(X[Y[True] | True]) .

    op amount : Nat -> Formula .
    eq amount(K) = <> 0 s(K) ('isRegistry[True] | True) .

    op delete : Name -> VTA .
    eq delete(X) =
        out(X) . out('asg) . in('trash)
        . ('restart_global[sdl | out('decision) . out('trash) . in('asg)
            . ('global_lock[sdl | zero] | open('key) . zero)]
          | 'restart_local[sdl | out('decision) . out('trash) . in('asg) . in(X)
            . ('local_lock[sdl | in('decision) . zero]
              | 'start[sdl | zero])]) .

    op moveTo : Name -> VTA .
    eq moveTo(X) =
        'move[sdl | out('decision) . out(X) . in('request)
          . in(X) . 'delete_sig[sdl | in('decision) . zero]] .

    op cleanUp : -> VTA .
    eq cleanUp =
        ! ('cleaner[sdl | open('call_clean_up)
          . open('deregistered) . out('asg)
          . in('trash) . 'inTrash[sdl | zero]]) .

    op remove : Name -> VTA .
    eq remove(X) =
        'call_clean_up[sdl | out('decision) . out(X) . in('cleaner) . in(X)
          . ('removal[sdl | out(X) . in('registry)
              . open('counter) . 'deregistered[sdl | out('registry) . in(X) . zero]]
            | open('inTrash) . 'restart_global[sdl | out(X) . out('trash) . in('asg)
              . ('global_lock[sdl | zero] | open('key) . zero)])] .

    op virtualMachine : Name -> VTA .
    eq virtualMachine(X) =
        X[sched 1 {0, 0, 0, empty, ('start,'isVM)}
          | 'start[sdl | zero]
          | ! (open('request) . zero)
          | ! (open('restart_local) . zero) | 'isVM[sdl | zero] | open('cleaner) . zero
          | ! (open('start) . 'key[sdl | out(X) . open('global_lock) . 'private_lock[sdl | in(X) . zero]])
          | ! (open('private_lock)
            . 'decision[sdl('local_lock) | ((~ full(X) /\ parallel(X, 'request))
                ? (open('local_lock) . (moveTo(X) | open('delete_sig) . delete(X))))
              | ((~ full(X) /\ ~ parallel(X, 'request) \/ full(X) \/
                  (empty(X) /\ amount(MIN) \/ parallel(X, 'request)))
                ? (open('local_lock) . delete(X)))
              | ((empty(X) /\ ~ amount(MIN) /\ ~ parallel(X, 'request))
                ? (open('local_lock) . remove(X) | 'local_lock[sdl | zero]))])] .

    op scaling : -> VTA .
    eq scaling =
        !< 'vm > (open('scaling_lock)
          . ((exists('request) /\ (all 'x . (full('x) \/ ~ 'x has 'isVM))) /\ amount(sd(MAX, 1)))
          ? ('counter[sdl | in('registry) . 'registered[sdl | out('counter) . out('registry) . zero]]
            | open('registered) . (virtualMachine('vm) | 'scaling_lock[sdl | zero]))) .

    op registry : -> VTA .
    eq registry =
        'registry[sdl('isRegistry)
          | 'isRegistry[sdl | zero]
          | ! (open('removal) . zero)] .

    op consumes : Nat -> VTA .
    eq consumes(0) = zero .
    eq consumes(s K) = c . consumes(K) .

    op request : Nat -> VTA .
    eq request(K) = 'request[sdl | in('asg) . open('move) . zero | consumes(K)] .

    op trash : -> VTA .
    eq trash = 'trash[sdl | zero ] .

    op asg : -> VTA .
    eq asg = 'asg[sched 1 {0, 0, 0, empty, ('registry,'scaling_lock,'global_lock)}
		| tick | tick | tick | tick | tick | tick | tick | tick | tick | tick
		| cleanUp | scaling | registry
		| 'scaling_lock[ sdl | zero] | 'global_lock[sdl | zero]
		|  ! (open('restart_global) . zero)] .

    op example : -> VTA .
    eq example = 'cloud[sdl(('asg, 'request, 'trash)) | asg | trash | request(1)] .
endm
