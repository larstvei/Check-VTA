fmod NAME is
    pr QID .

    sort Name .
    subsort Qid < Name .
endfm

fmod CAPABILITY is
    pr NAME .

    sort Capability .

    ops c : -> Capability .
    ops in out open : Name -> Capability .
endfm

fmod EGYPTIAN is
    pr NAT .
    pr RAT .
    pr LIST{Rat} .

    vars X Y Z : Int .

    op _mod_ : Int Int -> Int .
    eq X mod Y = Y + X rem Y .

    op egyptian : Rat -> List{Rat} .
    eq egyptian(X) = X .
    eq egyptian(1 / X) = 1 / X .
    ceq egyptian(X / Y) = (1 / Z) egyptian((- Y mod X) / (Y * Z))
      if Z := ceiling(Y / X) [owise] .

    var L : List{Rat} .
    var R : Rat .

    op speed : Rat -> List{Rat} .
    eq speed(R) = speed'(egyptian(R), 0) .

    op speed' : List{Rat} Nat -> List{Rat} .
    eq speed'(1 L, Y) = speed'(L, Y + 1) .
    eq speed'(L, Y) = Y size(L) [owise] .
endfm

mod TIMED-PROCESS is
    pr INT .
    pr RAT .
    pr BOOL .
    pr EGYPTIAN .
    pr CAPABILITY .

    sort Clock .
    sort Tick .

    op tick : -> Tick .

    sort TimedProcess .

    subsort Tick < TimedProcess .

    sort Servable .
    subsort TimedProcess Name < Servable .

    vars S T : Servable .
    op empty : -> Servable .
    op _,_ : Servable Servable -> Servable [assoc comm id: empty prec 30] .
    eq S, S = S .

    op _\_ : Servable Servable -> Servable [prec 100] .
    eq T, S \ S = T .
    eq T \ S = T [owise] .

    op isEmpty : Servable -> Bool .
    eq isEmpty(empty) = true .
    eq isEmpty(S) = false [owise] .

    op _isIn_ : Servable Servable -> Bool .
    eq S isIn (S, T) = true .
    eq S isIn T = false [owise] .

    op dead : -> TimedProcess [ctor] .
    op _|_ : TimedProcess TimedProcess -> TimedProcess [id: dead assoc comm prec 90] .
    op _._ : Capability TimedProcess -> TimedProcess [prec 80] .
    op _[_|_] : Name Clock TimedProcess -> TimedProcess [prec 70] .

    op clock : Nat Nat Nat Rat Servable Servable -> Clock .

    vars N M K : Name .
    vars CN1 CN2 CN3 CM1 CM2 CM3 CK1 CK2 CK3 : Nat .
    vars Speed SpdN SpdM SpdK : Rat .
    vars Cl Cl1 Cl2 Cl3 : Clock .
    var Ca : Capability .
    vars P Q R U : TimedProcess .
    vars Served Unserved : Servable .
    vars SrvN SrvM UnSrvK UnSrvN UnSrvM SrvK : Servable .

    op barb : TimedProcess -> Servable .
    eq barb(Ca . P | Q) = barb(Q) .
    eq barb(N[Cl | P] | Q) = N, barb(Q) .
    eq barb(P) = empty [owise] .

    op getConsume : Servable -> Servable .
    eq getConsume((c . P), Unserved) = c . P .
    eq getConsume(Unserved) = empty [owise] .

    crl [open] :
        M[clock(CM1, CM2, CM3, Speed, Served, Unserved)
          | open(N) . P | N[Cl | R] | Q]
      =>
        M[clock(CM1, CM2, CM3, Speed, S, T) | P | Q | R]
      if  S := (Served \ N) /\
          T := (Unserved \ N), barb(P), barb(R) /\
          N isIn (Served, Unserved) .

    crl [in] :
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK)
          | N[clock(CN1, CN2, CN3, SpdN, SrvN, UnSrvN) | in(M) . P | Q]
          | M[clock(CM1, CM2, CM3, SpdM, SrvM, UnSrvM) | R] | U]
      =>
        K[clock(CK1, CK2, CK3, SpdK, (UnSrvK \ N), (SrvK \ N))
          | M[clock(CM1, CM2, CM3, SpdM, SrvM, (UnSrvM, N)) | R |
            N[clock(CN1, CN2, CN3, SpdN, SrvN, (UnSrvN, barb(P))) | P | Q]] | U]
      if  N isIn (UnSrvK, SrvK) .

    crl [out] :
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK)
          | M[clock(CM1, CM2, CM3, SpdM, SrvM, UnSrvM) | R |
            N[clock(CN1, CN2, CN3, SpdN, SrvN, UnSrvN) | out(M) . P | Q]] | U]
      =>
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, (SrvK, N))
          | N[clock(CN1, CN2, CN3, SpdN, SrvN, (UnSrvN, barb(P))) | P | Q]
          | M[clock(CM1, CM2, CM3, SpdM, (SrvM \ N), (UnSrvM \ N)) | R] | U]
      if  N isIn (SrvM, UnSrvM) .

    crl [consumption] :
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK) | c . P | R]
      =>
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, (SrvK, (c . P))) | R]
      if SpdK > 0 .

    rl [empty]:
        K[clock(CK1, 0, 0, SpdK, empty, empty) | tick | R]
      =>
        K[clock(CK1 + 1, 0, 0, SpdK, empty, empty) | R] .

    crl [tick]:
        K[clock(CK1, 0, 0, SpdK, UnSrvK, SrvK) | tick | R]
      =>
        K[clock(CK1 + 1, CK2, CK3, SpdK, UnSrvK, SrvK) | R]
      if  CK2 CK3 := speed(SpdK) /\ not isEmpty(UnSrvK, SrvK) .

    crl [new-round] :
        K[clock(CK1, CK2, CK3, SpdK, empty, SrvK) | R]
      =>
        K[clock(CK1, CK2, CK3, SpdK, SrvK, empty) | R]
        if not isEmpty(SrvK) .

    crl [tock1] :
        K[clock(CK1, CK2, CK3, SpdK, UnSrvK, SrvK) | R]
      =>
        K[clock(CK1, CK2 - 1, CK3, SpdK, UnSrvN, SrvK) | R | P]
      if  CK2 > 0 /\ (c . P) := getConsume(UnSrvK) /\
          UnSrvN := (barb(P), UnSrvK \ (c . P)) .
endm

--- Examples
rew 'm[clock(0,0,0,0,'n,empty) | 'n[C1:Clock | 'p[C2:Clock | dead]]
      | open('n) . 'q[C3:Clock | dead]] .

rew 'k[clock(0,0,0,0,('n,'m),empty)
      | 'n[clock(0,0,0,0,empty,empty) | in('m) . dead]
      | 'm[clock(0,0,0,0,empty,empty) | dead]] .


rew 'k[clock(0,0,0,0,('m),empty)
     | 'm[clock(0,0,0,0,('n),empty) | dead
     | 'n[clock(0,0,0,0,empty,empty) | out('m) . dead]]] .

rew 'k[clock(0,0,0,1, empty, empty) | c . dead] .

rew 'k[clock(0,0,0,1, empty, empty) | tick] .

rew 'k[clock(0,0,0,1, 'n, empty) | tick] .

rew 'k[clock(0,0,0,1, empty, 'n) | tick] .

rew 'k[clock(0,1,0,1, (c . P:TimedProcess), 'n) | dead] .